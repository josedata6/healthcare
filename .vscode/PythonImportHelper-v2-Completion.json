[
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "read_first_two_lines",
        "kind": 2,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "def read_first_two_lines(path):\n    \"\"\"Return the first two lines and the rest of the file as text.\"\"\"\n    if path.endswith(\".gz\"):\n        with gzip.open(path, \"rt\", errors=\"replace\") as f:\n            l1 = f.readline().strip()\n            l2 = f.readline().strip()\n            rest = f.read()\n        return l1, l2, rest\n    else:\n        with open(path, \"r\", encoding=\"utf-8\", errors=\"replace\") as f:",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "clean_one_file",
        "kind": 2,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "def clean_one_file(src, dst, force_gzip=False):\n    \"\"\"Clean one CSV: strip top 2 rows, add as metadata column, write to dst.\"\"\"\n    os.makedirs(os.path.dirname(dst), exist_ok=True)\n    meta1, meta2, _ = read_first_two_lines(src)\n    metadata_text = f\"{meta1} | {meta2}\".strip(\" |\")\n    # Read file with pandas, skipping first 2 rows\n    read_kwargs = dict(\n        dtype=str,\n        sep=None,              # auto-detect delimiter\n        engine=\"python\",",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "def main():\n    files = []\n    for pat in (\"*.csv\", \"*.csv.gz\"):\n        files.extend(glob.glob(os.path.join(IN_DIR, pat)))\n    if not files:\n        print(f\"  No files found in {IN_DIR}\")\n        return\n    print(f\"Found {len(files)} file(s). Cleaning into {OUT_DIR} …\")\n    for src in sorted(files):\n        rel = os.path.relpath(src, IN_DIR)",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "OUT_DIR",
        "kind": 5,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "OUT_DIR = \"/Users/jdd48774/Documents/_BANA3/healthcare/hospitaldata_clean\" # cleaned files\nFORCE_GZIP = True   # set to True if you want all output as .csv.gz\n# ---------- Helpers ----------\ndef read_first_two_lines(path):\n    \"\"\"Return the first two lines and the rest of the file as text.\"\"\"\n    if path.endswith(\".gz\"):\n        with gzip.open(path, \"rt\", errors=\"replace\") as f:\n            l1 = f.readline().strip()\n            l2 = f.readline().strip()\n            rest = f.read()",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "FORCE_GZIP",
        "kind": 5,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "FORCE_GZIP = True   # set to True if you want all output as .csv.gz\n# ---------- Helpers ----------\ndef read_first_two_lines(path):\n    \"\"\"Return the first two lines and the rest of the file as text.\"\"\"\n    if path.endswith(\".gz\"):\n        with gzip.open(path, \"rt\", errors=\"replace\") as f:\n            l1 = f.readline().strip()\n            l2 = f.readline().strip()\n            rest = f.read()\n        return l1, l2, rest",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "open_any",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def open_any(path: str):\n    \"\"\"Open text or gzipped CSV as text, letting pandas handle encoding.\"\"\"\n    return gzip.open(path, \"rt\", errors=\"replace\") if path.endswith(\".gz\") else open(path, \"r\", errors=\"replace\")\ndef _try_read(path: str, encoding: str, sep, engine: str):\n    df = pd.read_csv(\n        open_any(path),\n        dtype=str,\n        encoding=encoding,\n        sep=sep,                 # None => auto (engine='python')\n        engine=engine,           # 'python' parser is more forgiving",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "read_csv_any",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def read_csv_any(path: str) -> pd.DataFrame:\n    \"\"\"Robust CSV reader trying common encodings and delimiters.\"\"\"\n    for encoding in (\"utf-8\", \"latin-1\"):\n        for sep in (None, \",\", \"\\t\", \"|\", \";\"):\n            try:\n                df = _try_read(path, encoding=encoding, sep=sep, engine=\"python\")\n                print(f\"   ✓ Parsed with encoding={encoding} sep={'auto' if sep is None else sep}\")\n                return df\n            except Exception:\n                continue",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "normalize_header",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def normalize_header(col: str) -> str:\n    c = str(col).strip().lower()\n    c = c.replace(\"-\", \"_\")             # dashes → underscores\n    c = re.sub(r\"\\s*\\|\\s*\", \"|\", c)     # \" a | b \" → \"a|b\"\n    c = re.sub(r\"\\s+\", \" \", c)          # collapse spaces\n    return c\ndef is_charge_col(col: str) -> bool:\n    \"\"\"\n    Accept many real-world variants:\n      - standard_charge|gross, standard charge|gross, standard_charge (no suffix)",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "is_charge_col",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def is_charge_col(col: str) -> bool:\n    \"\"\"\n    Accept many real-world variants:\n      - standard_charge|gross, standard charge|gross, standard_charge (no suffix)\n      - standard_charge|discounted_cash|min|max\n      - bare names: gross_charge, chargemaster, discounted_cash, negotiated_dollar, negotiated_percentage, min, max\n    \"\"\"\n    c = normalize_header(col)\n    if c in (\"standard_charge\", \"standard charge\"):\n        return True",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "col_to_price_type_from_name",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def col_to_price_type_from_name(col: str) -> str:\n    \"\"\"Map a (possibly deduped) charge column name to canonical price_type.\"\"\"\n    b = col.split(\"__\", 1)[0]  # strip any __N suffix\n    # extract suffix after \"standard_charge|\"\n    if \"|\" in b:\n        suffix = b.split(\"|\", 1)[1]\n    else:\n        bare = b.replace(\" \", \"_\")\n        if bare in (\"gross\", \"gross_charge\", \"gross_charges\", \"chargemaster\", \"standard_charge\"):\n            suffix = \"gross\"",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "col_or_blank",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def col_or_blank(df, col):\n    \"\"\"Return df[col] if it exists, else a same-length Series of empty strings.\"\"\"\n    if col in df.columns:\n        return df[col].fillna(\"\")\n    else:\n        return pd.Series([\"\"] * len(df), index=df.index)\ndef _make_unique(names):\n    seen = {}\n    out = []\n    for n in names:",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "guess_hospital_name_from_filename",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def guess_hospital_name_from_filename(path: str) -> str:\n    \"\"\"\n    Heuristics to turn filenames like:\n      '911352172_mary-bridge-childrens-hospital_standardcharges.csv'\n      '91-0750229_Mid-Valley_Hospital_standardcharges.csv'\n      '20250115_Providence_Sacred_Heart_standard_charges.csv.gz'\n    into: 'Mary Bridge Childrens Hospital', 'Mid Valley Hospital', 'Providence Sacred Heart'\n    \"\"\"\n    base = os.path.basename(path)\n    base = re.sub(r\"\\.csv(\\.gz)?$\", \"\", base, flags=re.IGNORECASE)",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "melt_and_normalize",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def melt_and_normalize(df: pd.DataFrame, hospital_name: str) -> pd.DataFrame:\n    # 0) normalize and dedupe headers\n    df = df.copy()\n    df.columns = [normalize_header(c) for c in df.columns]\n    if len(set(df.columns)) != len(df.columns):\n        df.columns = _make_unique(df.columns)\n        print(\"   ↳ detected duplicate headers; made them unique.\")\n    cols = list(df.columns)\n    # helper: first existing column whose base-name matches any candidate\n    def pick_first(*candidates):",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "copy_to_single_table",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def copy_to_single_table(df, source_file):\n    cols = [\n        \"hospital_name\",\"code\",\"code_type\",\"price_type\",\"price_amount\",\n        \"payer_name\",\"billing_class\",\"currency\",\"effective_date\",\"expires_on\",\n        \"description\",\"notes\"\n    ]\n    for c in cols:\n        if c not in df.columns:\n            df[c] = \"\"\n    df = df.copy()",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def main():\n    files = sorted(glob.glob(os.path.join(DATA_DIR, \"*.csv\")) + glob.glob(os.path.join(DATA_DIR, \"*.csv.gz\")))\n    if not files:\n        print(\"No files found in\", DATA_DIR)\n        return\n    for path in files:\n        hosp = guess_hospital_name_from_filename(path)\n        print(f\"--> Processing {os.path.basename(path)}  |  inferred hospital: {hosp}\")\n        df = read_csv_any(path)\n        tidy = melt_and_normalize(df, hospital_name=hosp)",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "DATA_DIR = \"/Users/jdd48774/Downloads/raw_data5kbs\"  # folder with CSV/CSV.GZ\nENGINE   = create_engine(DB_URL, future=True)\n# Map charge suffix -> canonical price_type\nPRICE_TYPE_MAP = {\n    \"gross\": \"chargemaster\",\n    \"gross_charge\": \"chargemaster\",\n    \"gross_charges\": \"chargemaster\",\n    \"discounted_cash\": \"cash\",\n    \"negotiated_dollar\": \"negotiated\",\n    \"negotiated_percentage\": \"percentage\",",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "PRICE_TYPE_MAP",
        "kind": 5,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "PRICE_TYPE_MAP = {\n    \"gross\": \"chargemaster\",\n    \"gross_charge\": \"chargemaster\",\n    \"gross_charges\": \"chargemaster\",\n    \"discounted_cash\": \"cash\",\n    \"negotiated_dollar\": \"negotiated\",\n    \"negotiated_percentage\": \"percentage\",\n    \"min\": \"min\",\n    \"max\": \"max\",\n}",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "_BOILER_PATTERNS",
        "kind": 5,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "_BOILER_PATTERNS = [\n    r\"standard[_-]?charges?\", r\"machine[_-]?readable\",\n    r\"(price|prices?)\", r\"chargemaster\", r\"cdm\",\n    r\"inpatient\", r\"outpatient\", r\"shoppable\"\n]\ndef guess_hospital_name_from_filename(path: str) -> str:\n    \"\"\"\n    Heuristics to turn filenames like:\n      '911352172_mary-bridge-childrens-hospital_standardcharges.csv'\n      '91-0750229_Mid-Valley_Hospital_standardcharges.csv'",
        "detail": "load-csv-database",
        "documentation": {}
    }
]