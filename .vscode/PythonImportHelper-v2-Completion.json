[
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "read_first_lines",
        "kind": 2,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "def read_first_lines(path, n=3):\n    \"\"\"Return the first n lines of a file as list of strings.\"\"\"\n    opener = gzip.open if path.endswith(\".gz\") else open\n    with opener(path, \"rt\", errors=\"replace\", encoding=\"utf-8\") as f:\n        return [f.readline().strip() for _ in range(n)]\ndef should_strip_metadata(lines):\n    \"\"\"\n    Decide if first 2 rows are metadata (not real headers).\n    Returns True if we should strip them.\n    \"\"\"",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "should_strip_metadata",
        "kind": 2,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "def should_strip_metadata(lines):\n    \"\"\"\n    Decide if first 2 rows are metadata (not real headers).\n    Returns True if we should strip them.\n    \"\"\"\n    header_line = lines[0].lower() if lines else \"\"\n    # If the first line already has expected headers, keep it\n    if any(h in header_line for h in EXPECTED_HEADERS):\n        return False\n    return True",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "clean_one_file",
        "kind": 2,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "def clean_one_file(src, dst, force_gzip=False):\n    os.makedirs(os.path.dirname(dst), exist_ok=True)\n    # Peek at first 3 lines\n    lines = read_first_lines(src, n=3)\n    if should_strip_metadata(lines):\n        print(f\"   → stripping top 2 rows from {os.path.basename(src)}\")\n        skiprows = 2\n        meta1, meta2 = lines[0], lines[1]\n        metadata_text = f\"{meta1} | {meta2}\".strip(\" |\")\n    else:",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "def main():\n    files = []\n    for pat in (\"*.csv\", \"*.csv.gz\"):\n        files.extend(glob.glob(os.path.join(IN_DIR, pat)))\n    if not files:\n        print(f\"  No files found in {IN_DIR}\")\n        return\n    print(f\"Found {len(files)} file(s). Cleaning into {OUT_DIR} …\")\n    for src in sorted(files):\n        rel = os.path.relpath(src, IN_DIR)",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "OUT_DIR",
        "kind": 5,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "OUT_DIR = \"/Users/jdd48774/Documents/_BANA3/healthcare/hospitaldata_clean\" # cleaned files\nFORCE_GZIP = True   # True → output .csv.gz, False → plain .csv\n# Keywords we expect in a valid header row\nEXPECTED_HEADERS = [\n    \"description\", \"code|1\", \"code|1|type\", \"standard_charge|gross\",\n    \"standard_charge|discounted_cash\", \"payer_name\", \"plan_name\"\n]\ndef read_first_lines(path, n=3):\n    \"\"\"Return the first n lines of a file as list of strings.\"\"\"\n    opener = gzip.open if path.endswith(\".gz\") else open",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "FORCE_GZIP",
        "kind": 5,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "FORCE_GZIP = True   # True → output .csv.gz, False → plain .csv\n# Keywords we expect in a valid header row\nEXPECTED_HEADERS = [\n    \"description\", \"code|1\", \"code|1|type\", \"standard_charge|gross\",\n    \"standard_charge|discounted_cash\", \"payer_name\", \"plan_name\"\n]\ndef read_first_lines(path, n=3):\n    \"\"\"Return the first n lines of a file as list of strings.\"\"\"\n    opener = gzip.open if path.endswith(\".gz\") else open\n    with opener(path, \"rt\", errors=\"replace\", encoding=\"utf-8\") as f:",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "EXPECTED_HEADERS",
        "kind": 5,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "EXPECTED_HEADERS = [\n    \"description\", \"code|1\", \"code|1|type\", \"standard_charge|gross\",\n    \"standard_charge|discounted_cash\", \"payer_name\", \"plan_name\"\n]\ndef read_first_lines(path, n=3):\n    \"\"\"Return the first n lines of a file as list of strings.\"\"\"\n    opener = gzip.open if path.endswith(\".gz\") else open\n    with opener(path, \"rt\", errors=\"replace\", encoding=\"utf-8\") as f:\n        return [f.readline().strip() for _ in range(n)]\ndef should_strip_metadata(lines):",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "open_any",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def open_any(path: str):\n    \"\"\"Open text or gzipped CSV as text, letting pandas handle encoding.\"\"\"\n    return gzip.open(path, \"rt\", errors=\"replace\") if path.endswith(\".gz\") else open(path, \"r\", errors=\"replace\")\ndef _try_read(path: str, encoding: str, sep, engine: str):\n    df = pd.read_csv(\n        open_any(path),\n        dtype=str,\n        encoding=encoding,\n        sep=sep,                 # None => auto (engine='python')\n        engine=engine,           # 'python' parser is more forgiving",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "read_csv_any",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def read_csv_any(path: str) -> pd.DataFrame:\n    \"\"\"Robust CSV reader trying common encodings and delimiters.\"\"\"\n    for encoding in (\"utf-8\", \"latin-1\"):\n        for sep in (None, \",\", \"\\t\", \"|\", \";\"):\n            try:\n                df = _try_read(path, encoding=encoding, sep=sep, engine=\"python\")\n                print(f\"   ✓ Parsed with encoding={encoding} sep={'auto' if sep is None else sep}\")\n                return df\n            except Exception:\n                continue",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "normalize_header",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def normalize_header(col: str) -> str:\n    c = str(col).strip().lower()\n    c = c.replace(\"-\", \"_\")             # dashes → underscores\n    c = re.sub(r\"\\s*\\|\\s*\", \"|\", c)     # \" a | b \" → \"a|b\"\n    c = re.sub(r\"\\s+\", \" \", c)          # collapse spaces\n    return c\ndef is_charge_col(col: str) -> bool:\n    \"\"\"\n    Accept many real-world variants:\n      - standard_charge|gross, standard charge|gross, standard_charge (no suffix)",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "is_charge_col",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def is_charge_col(col: str) -> bool:\n    \"\"\"\n    Accept many real-world variants:\n      - standard_charge|gross, standard charge|gross, standard_charge (no suffix)\n      - standard_charge|discounted_cash|min|max\n      - bare names: gross_charge, chargemaster, discounted_cash, negotiated_dollar, negotiated_percentage, min, max\n    \"\"\"\n    c = normalize_header(col)\n    if c in (\"standard_charge\", \"standard charge\"):\n        return True",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "col_to_price_type_from_name",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def col_to_price_type_from_name(col: str) -> str:\n    \"\"\"Map a (possibly deduped) charge column name to canonical price_type.\"\"\"\n    b = col.split(\"__\", 1)[0]  # strip any __N suffix\n    # extract suffix after \"standard_charge|\"\n    if \"|\" in b:\n        suffix = b.split(\"|\", 1)[1]\n    else:\n        bare = b.replace(\" \", \"_\")\n        if bare in (\"gross\", \"gross_charge\", \"gross_charges\", \"chargemaster\", \"standard_charge\"):\n            suffix = \"gross\"",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "col_or_blank",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def col_or_blank(df, col):\n    \"\"\"Return df[col] if it exists, else a same-length Series of empty strings.\"\"\"\n    if col in df.columns:\n        return df[col].fillna(\"\")\n    else:\n        return pd.Series([\"\"] * len(df), index=df.index)\ndef _make_unique(names):\n    seen = {}\n    out = []\n    for n in names:",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "guess_hospital_name_from_filename",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def guess_hospital_name_from_filename(path: str) -> str:\n    \"\"\"\n    Heuristics to turn filenames like:\n      '911352172_mary-bridge-childrens-hospital_standardcharges.csv'\n      '91-0750229_Mid-Valley_Hospital_standardcharges.csv'\n      '20250115_Providence_Sacred_Heart_standard_charges.csv.gz'\n    into: 'Mary Bridge Childrens Hospital', 'Mid Valley Hospital', 'Providence Sacred Heart'\n    \"\"\"\n    base = os.path.basename(path)\n    base = re.sub(r\"\\.csv(\\.gz)?$\", \"\", base, flags=re.IGNORECASE)",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "melt_and_normalize",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def melt_and_normalize(df: pd.DataFrame, hospital_name: str) -> pd.DataFrame:\n    # 0) normalize and dedupe headers\n    df = df.copy()\n    df.columns = [normalize_header(c) for c in df.columns]\n    if len(set(df.columns)) != len(df.columns):\n        df.columns = _make_unique(df.columns)\n        print(\"   ↳ detected duplicate headers; made them unique.\")\n    cols = list(df.columns)\n    # helper: first existing column whose base-name matches any candidate\n    def pick_first(*candidates):",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "copy_to_single_table",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def copy_to_single_table(df, source_file):\n    cols = [\n        \"hospital_name\",\"code\",\"code_type\",\"price_type\",\"price_amount\",\n        \"payer_name\",\"billing_class\",\"currency\",\"effective_date\",\"expires_on\",\n        \"description\",\"notes\"\n    ]\n    for c in cols:\n        if c not in df.columns:\n            df[c] = \"\"\n    df = df.copy()",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def main():\n    files = sorted(glob.glob(os.path.join(DATA_DIR, \"*.csv\")) + glob.glob(os.path.join(DATA_DIR, \"*.csv.gz\")))\n    if not files:\n        print(\"No files found in\", DATA_DIR)\n        return\n    for path in files:\n        hosp = guess_hospital_name_from_filename(path)\n        print(f\"--> Processing {os.path.basename(path)}  |  inferred hospital: {hosp}\")\n        df = read_csv_any(path)\n        tidy = melt_and_normalize(df, hospital_name=hosp)",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "DATA_DIR = \"/Users/jdd48774/Downloads/raw_data5kbs\"  # folder with CSV/CSV.GZ\nENGINE   = create_engine(DB_URL, future=True)\n# Map charge suffix -> canonical price_type\nPRICE_TYPE_MAP = {\n    \"gross\": \"chargemaster\",\n    \"gross_charge\": \"chargemaster\",\n    \"gross_charges\": \"chargemaster\",\n    \"discounted_cash\": \"cash\",\n    \"negotiated_dollar\": \"negotiated\",\n    \"negotiated_percentage\": \"percentage\",",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "PRICE_TYPE_MAP",
        "kind": 5,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "PRICE_TYPE_MAP = {\n    \"gross\": \"chargemaster\",\n    \"gross_charge\": \"chargemaster\",\n    \"gross_charges\": \"chargemaster\",\n    \"discounted_cash\": \"cash\",\n    \"negotiated_dollar\": \"negotiated\",\n    \"negotiated_percentage\": \"percentage\",\n    \"min\": \"min\",\n    \"max\": \"max\",\n}",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "_BOILER_PATTERNS",
        "kind": 5,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "_BOILER_PATTERNS = [\n    r\"standard[_-]?charges?\", r\"machine[_-]?readable\",\n    r\"(price|prices?)\", r\"chargemaster\", r\"cdm\",\n    r\"inpatient\", r\"outpatient\", r\"shoppable\"\n]\ndef guess_hospital_name_from_filename(path: str) -> str:\n    \"\"\"\n    Heuristics to turn filenames like:\n      '911352172_mary-bridge-childrens-hospital_standardcharges.csv'\n      '91-0750229_Mid-Valley_Hospital_standardcharges.csv'",
        "detail": "load-csv-database",
        "documentation": {}
    }
]