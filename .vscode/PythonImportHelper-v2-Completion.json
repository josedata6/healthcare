[
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "open_text",
        "kind": 2,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "def open_text(path):\n    if path.lower().endswith(\".gz\"):\n        return gzip.open(path, \"rt\", errors=\"replace\", encoding=\"utf-8\")\n    return open(path, \"r\", errors=\"replace\", encoding=\"utf-8\")\ndef first_lines(path, n=3):\n    with open_text(path) as f:\n        return [f.readline() for _ in range(n)]\ndef normalize(s: str) -> str:\n    if not isinstance(s, str):\n        s = str(s)",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "first_lines",
        "kind": 2,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "def first_lines(path, n=3):\n    with open_text(path) as f:\n        return [f.readline() for _ in range(n)]\ndef normalize(s: str) -> str:\n    if not isinstance(s, str):\n        s = str(s)\n    # unify whitespace and separators for matching\n    s = s.replace(\"\\u00A0\", \" \")       # NBSP -> space\n    s = s.replace(\"\\u2007\", \" \")       # figure space\n    s = s.replace(\"\\u202F\", \" \")       # narrow NBSP",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "normalize",
        "kind": 2,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "def normalize(s: str) -> str:\n    if not isinstance(s, str):\n        s = str(s)\n    # unify whitespace and separators for matching\n    s = s.replace(\"\\u00A0\", \" \")       # NBSP -> space\n    s = s.replace(\"\\u2007\", \" \")       # figure space\n    s = s.replace(\"\\u202F\", \" \")       # narrow NBSP\n    s = re.sub(r\"\\s+\", \" \", s)\n    s = s.strip().lower()\n    return s",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "score_header",
        "kind": 2,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "def score_header(raw_header_line: str) -> int:\n    \"\"\"Give a higher score if header looks like a charge file header, not admin.\"\"\"\n    h = normalize(raw_header_line)\n    score = 0\n    # reward pricing tokens\n    for tok in EXPECTED_TOKENS:\n        if tok in h:\n            score += 2\n    # penalize if it's clearly admin-y\n    for tok in ADMIN_HINTS:",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "read_csv_pass",
        "kind": 2,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "def read_csv_pass(path, skiprows=0):\n    \"\"\"Read with pandas in a tolerant way (autodetect delimiter).\"\"\"\n    return pd.read_csv(\n        open_text(path),\n        dtype=str,\n        sep=None, engine=\"python\",  # autodetect delimiter\n        quotechar='\"',\n        on_bad_lines=\"skip\",\n        skipinitialspace=True,\n        keep_default_na=False,",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "clean_one_file",
        "kind": 2,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "def clean_one_file(src_path, out_path):\n    os.makedirs(os.path.dirname(out_path), exist_ok=True)\n    # Pass A: assume first row is header\n    lines = first_lines(src_path, n=3)\n    line1 = lines[0] if lines else \"\"\n    score_A = score_header(line1)\n    # Pass B: strip the first 2 rows (common WA admin header + attestation)\n    line3 = lines[2] if len(lines) >= 3 else \"\"\n    score_B = score_header(line3)\n    # If Pass B header looks more like a pricing header, use Pass B",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "def main():\n    files = []\n    for pat in (\"*.csv\", \"*.csv.gz\"):\n        files.extend(glob.glob(os.path.join(IN_DIR, pat)))\n    if not files:\n        print(f\"⚠️  No files found in {IN_DIR}\")\n        return\n    print(f\"Found {len(files)} file(s). Cleaning into {OUT_DIR} …\")\n    for src in sorted(files):\n        rel = os.path.relpath(src, IN_DIR)",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "OUT_DIR",
        "kind": 5,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "OUT_DIR = \"/Users/jdd48774/Downloads/hospitaldata_clean\" # cleaned folder\nFORCE_GZIP = True  # True -> write .csv.gz\n# Pricing/structure headers we expect in a REAL header row\nEXPECTED_TOKENS = {\n    \"description\", \"code|\", \"code|1\", \"code|1|type\", \"code|2\", \"code|2|type\",\n    \"standard_charge\", \"standard_charge|gross\", \"standard_charge|discounted_cash\",\n    \"standard_charge|negotiated_dollar\", \"standard_charge|negotiated_percentage\",\n    \"standard_charge|min\", \"standard_charge|max\",\n    \"payer_name\", \"plan_name\", \"billing_class\", \"setting\", \"currency\",\n}",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "FORCE_GZIP",
        "kind": 5,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "FORCE_GZIP = True  # True -> write .csv.gz\n# Pricing/structure headers we expect in a REAL header row\nEXPECTED_TOKENS = {\n    \"description\", \"code|\", \"code|1\", \"code|1|type\", \"code|2\", \"code|2|type\",\n    \"standard_charge\", \"standard_charge|gross\", \"standard_charge|discounted_cash\",\n    \"standard_charge|negotiated_dollar\", \"standard_charge|negotiated_percentage\",\n    \"standard_charge|min\", \"standard_charge|max\",\n    \"payer_name\", \"plan_name\", \"billing_class\", \"setting\", \"currency\",\n}\n# “Admin-only” tokens that frequently show up in those top 2 rows (metadata)",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "EXPECTED_TOKENS",
        "kind": 5,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "EXPECTED_TOKENS = {\n    \"description\", \"code|\", \"code|1\", \"code|1|type\", \"code|2\", \"code|2|type\",\n    \"standard_charge\", \"standard_charge|gross\", \"standard_charge|discounted_cash\",\n    \"standard_charge|negotiated_dollar\", \"standard_charge|negotiated_percentage\",\n    \"standard_charge|min\", \"standard_charge|max\",\n    \"payer_name\", \"plan_name\", \"billing_class\", \"setting\", \"currency\",\n}\n# “Admin-only” tokens that frequently show up in those top 2 rows (metadata)\nADMIN_HINTS = {\n    \"hospital_name\", \"last_updated_on\", \"hospital_location\", \"hospital_address\",",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "ADMIN_HINTS",
        "kind": 5,
        "importPath": "clean-csv-hospitalData",
        "description": "clean-csv-hospitalData",
        "peekOfCode": "ADMIN_HINTS = {\n    \"hospital_name\", \"last_updated_on\", \"hospital_location\", \"hospital_address\",\n    \"license_number|\", \"license_number|wa\", \"version\",\n    \"to the best of its knowledge\",  # attestation text\n    \"45 cfr 180.50\", \"attestation\", \"standard charge information\"\n}\n# ============================================\ndef open_text(path):\n    if path.lower().endswith(\".gz\"):\n        return gzip.open(path, \"rt\", errors=\"replace\", encoding=\"utf-8\")",
        "detail": "clean-csv-hospitalData",
        "documentation": {}
    },
    {
        "label": "open_any",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def open_any(path: str):\n    \"\"\"Open text or gzipped CSV as text, letting pandas handle encoding.\"\"\"\n    return gzip.open(path, \"rt\", errors=\"replace\") if path.endswith(\".gz\") else open(path, \"r\", errors=\"replace\")\ndef _try_read(path: str, encoding: str, sep, engine: str):\n    df = pd.read_csv(\n        open_any(path),\n        dtype=str,\n        encoding=encoding,\n        sep=sep,                 # None => auto (engine='python')\n        engine=engine,           # 'python' parser is more forgiving",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "read_csv_any",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def read_csv_any(path: str) -> pd.DataFrame:\n    \"\"\"Robust CSV reader trying common encodings and delimiters.\"\"\"\n    for encoding in (\"utf-8\", \"latin-1\"):\n        for sep in (None, \",\", \"\\t\", \"|\", \";\"):\n            try:\n                df = _try_read(path, encoding=encoding, sep=sep, engine=\"python\")\n                print(f\"   ✓ Parsed with encoding={encoding} sep={'auto' if sep is None else sep}\")\n                return df\n            except Exception:\n                continue",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "normalize_header",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def normalize_header(col: str) -> str:\n    c = str(col).strip().lower()\n    c = c.replace(\"-\", \"_\")             # dashes → underscores\n    c = re.sub(r\"\\s*\\|\\s*\", \"|\", c)     # \" a | b \" → \"a|b\"\n    c = re.sub(r\"\\s+\", \" \", c)          # collapse spaces\n    return c\ndef is_charge_col(col: str) -> bool:\n    \"\"\"\n    Accept many real-world variants:\n      - standard_charge|gross, standard charge|gross, standard_charge (no suffix)",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "is_charge_col",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def is_charge_col(col: str) -> bool:\n    \"\"\"\n    Accept many real-world variants:\n      - standard_charge|gross, standard charge|gross, standard_charge (no suffix)\n      - standard_charge|discounted_cash|min|max\n      - bare names: gross_charge, chargemaster, discounted_cash, negotiated_dollar, negotiated_percentage, min, max\n    \"\"\"\n    c = normalize_header(col)\n    if c in (\"standard_charge\", \"standard charge\"):\n        return True",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "col_to_price_type_from_name",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def col_to_price_type_from_name(col: str) -> str:\n    \"\"\"Map a (possibly deduped) charge column name to canonical price_type.\"\"\"\n    b = col.split(\"__\", 1)[0]  # strip any __N suffix\n    # extract suffix after \"standard_charge|\"\n    if \"|\" in b:\n        suffix = b.split(\"|\", 1)[1]\n    else:\n        bare = b.replace(\" \", \"_\")\n        if bare in (\"gross\", \"gross_charge\", \"gross_charges\", \"chargemaster\", \"standard_charge\"):\n            suffix = \"gross\"",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "col_or_blank",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def col_or_blank(df, col):\n    \"\"\"Return df[col] if it exists, else a same-length Series of empty strings.\"\"\"\n    if col in df.columns:\n        return df[col].fillna(\"\")\n    else:\n        return pd.Series([\"\"] * len(df), index=df.index)\ndef _make_unique(names):\n    seen = {}\n    out = []\n    for n in names:",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "melt_and_normalize",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def melt_and_normalize(df: pd.DataFrame, hospital_name: str) -> pd.DataFrame:\n    # 0) normalize and dedupe headers\n    df = df.copy()\n    df.columns = [normalize_header(c) for c in df.columns]\n    if len(set(df.columns)) != len(df.columns):\n        df.columns = _make_unique(df.columns)\n        print(\"   ↳ detected duplicate headers; made them unique.\")\n    cols = list(df.columns)\n    # helper: first existing column whose base-name matches any candidate\n    def pick_first(*candidates):",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "copy_to_single_table",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def copy_to_single_table(df, source_file):\n    cols = [\n        \"hospital_name\",\"code\",\"code_type\",\"price_type\",\"price_amount\",\n        \"payer_name\",  \"plan_name\", \"billing_class\",\"currency\",\"effective_date\",\"expires_on\",\n        \"description\",\"notes\"\n    ]\n    for c in cols:\n        if c not in df.columns:\n            df[c] = \"\"\n    df = df.copy()",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "def main():\n    files = sorted(glob.glob(os.path.join(DATA_DIR, \"*.csv\")) + glob.glob(os.path.join(DATA_DIR, \"*.csv.gz\")))\n    if not files:\n        print(\"No files found in\", DATA_DIR)\n        return\n    for path in files:\n        hosp = input(f\"Hospital name for {os.path.basename(path)}: \").strip()\n        print(f\"--> Processing {os.path.basename(path)} for hospital={hosp}\")\n        df = read_csv_any(path)\n        tidy = melt_and_normalize(df, hospital_name=hosp)",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "DATA_DIR",
        "kind": 5,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "DATA_DIR = \"/Users/jdd48774/Documents/_BANA3/healthcare/hospitaldata5\" ## path for files to load\nENGINE   = create_engine(DB_URL, future=True)\n# Map charge suffix -> canonical price_type\nPRICE_TYPE_MAP = {\n    \"gross\": \"chargemaster\",\n    \"gross_charge\": \"chargemaster\",\n    \"gross_charges\": \"chargemaster\",\n    \"discounted_cash\": \"cash\",\n    \"negotiated_dollar\": \"negotiated\",\n    \"negotiated_percentage\": \"percentage\",",
        "detail": "load-csv-database",
        "documentation": {}
    },
    {
        "label": "PRICE_TYPE_MAP",
        "kind": 5,
        "importPath": "load-csv-database",
        "description": "load-csv-database",
        "peekOfCode": "PRICE_TYPE_MAP = {\n    \"gross\": \"chargemaster\",\n    \"gross_charge\": \"chargemaster\",\n    \"gross_charges\": \"chargemaster\",\n    \"discounted_cash\": \"cash\",\n    \"negotiated_dollar\": \"negotiated\",\n    \"negotiated_percentage\": \"percentage\",\n    \"min\": \"min\",\n    \"max\": \"max\",\n}",
        "detail": "load-csv-database",
        "documentation": {}
    }
]